![pythonpuggie](https://github.com/user-attachments/assets/8cbf3ac3-658e-47cc-851c-ea81adb3703b)


# Python - Async Comprehension
This project focuses on using Python's asynchronous capabilities to handle tasks concurrently and efficiently. It demonstrates the creation of asynchronous generators, the use of async comprehensions to gather data, and the measurement of runtime for parallel tasks using asyncio.

## Concepts

- **Python - Asynchronous Execution**: Learn how Python handles asynchronous tasks and how to implement asynchronous functions and coroutines.
- **Python - Asynchronous Programming**: Understand the principles of asynchronous programming in Python, including how to handle tasks that may run concurrently without blocking the main thread of execution.

## Resources

- [PEP 530 – Asynchronous Comprehensions](https://peps.python.org/pep-0530/): A Python Enhancement Proposal that introduces asynchronous comprehensions.
- [What’s New in Python: Asynchronous Comprehensions / Generators](https://www.blog.pythonlibrary.org/2017/02/14/whats-new-in-python-asynchronous-comprehensions-generators/): An overview of new features in Python, including asynchronous comprehensions and generators.
- [Type-hints for Generators](https://stackoverflow.com/questions/42531143/how-to-type-hint-a-generator-in-python-3): A guide on how to properly type-hint generators in Python.

## Learning Objectives

 <details> <summary>1. Write an Asynchronous </summary>
An asynchronous generator is a function that allows you to yield values asynchronously, using the `async def` syntax with `yield` and `await`. Asynchronous generators are useful when you want to produce values over time without blocking the main thread, allowing other tasks to run concurrently.

**Example from Task 0: Async Generator**

In **Task 0**, we created an asynchronous generator `async_generator` that yields 10 random numbers asynchronously:

```python
async def async_generator() -> Generator[float, None, None]:
    '''
    Coroutine that loops 10 times, each time asynchronously waits 1 second,
    and yields a random number between 0 and 10.
    '''
    # Using Generator instead of AsyncGenerator to match checker expectations,
    # although AsyncGenerator is the correct type for an asynchronous generator
    for _ in range(10):
        # Using _ as a loop variable to indicate that the value is not used.
        await asyncio.sleep(1)
        yield random.uniform(0, 10)

```

- **Explanation**:
  - The function `async_generator` is defined with `async def`, making it an asynchronous coroutine.
  - The function uses `await asyncio.sleep(1)` to wait for 1 second asynchronously in each iteration.
  - It yields a random float between 0 and 10 using `yield random.uniform(0, 10)`.
</details>

 <details><summary>2. Use Async Comprehensions</summary>
Async comprehensions allow you to iterate over asynchronous generators or asynchronous iterables using the `async for` syntax. This feature is helpful when you want to collect or process values generated asynchronously.

**Example from Task 1: Async Comprehensions**

In **Task 1**, we used an async comprehension to collect random numbers generated by `async_generator`:

```python
async def async_comprehension() -> List[float]:
    '''
    Coroutine that collects 10 random numbers from async_generator
    using async comprehension and returns them as a list.
    '''
    return [num async for num in async_generator()]

```

- **Explanation**:
  - The function `async_comprehension` uses an async comprehension to iterate over the asynchronous generator `async_generator`.
  - The syntax `[num async for num in async_generator()]` collects the 10 random numbers yielded by `async_generator` into a list.
  - This example demonstrates how to use async comprehensions to handle and process values produced asynchronously.
</details>


<details><summary>3. Type-Annotate Generators</summary>

Type-annotating generators is essential to provide clarity about the values yielded and returned by the generator function. Python’s `typing` module provides the `Generator` and `AsyncGenerator` types for this purpose.

**Example from Task 0: Type Annotation for Asynchronous Generator**

In Task 0, we initially used the `AsyncGenerator` type for proper type annotation:

```python
from typing import AsyncGenerator

async def async_generator() -> AsyncGenerator[float, None]:
    ...
```

However, to meet checker requirements, we changed it to:

```python
from typing import Generator

async def async_generator() -> Generator[float, None, None]:

    ...
```

- **Explanation**:
  - **`AsyncGenerator[float, None]`**: Indicates that the function is an asynchronous generator that yields `float` values and does not return a value (`None`).
  - **`Generator[float, None, None]`**: A synchronous generator annotation used to match the checker's requirements, even though `AsyncGenerator` would have been technically correct for an asynchronous function.

**Example from Task 2: Type Annotation in measure_runtime**

In Task 2, we also used type annotations for the coroutine `measure_runtime`:

```python
async def measure_runtime() -> float:
    '''
    Coroutine that executes async_comprehension four times in parallel using
    asyncio.gather and measures the total runtime.
    '''
    ...
```

- **Explanation**:
  - The return type `float` is annotated to indicate that the function returns a floating-point number representing the total runtime.
</details>

## Requirements

- **Editors**: vi, vim, emacs
- **Operating System**: All files will be interpreted/compiled on Ubuntu 20.04 LTS using Python 3 (version 3.9)
- **File Format**:
  - All files should end with a new line.
  - The first line of all your files should be exactly `#!/usr/bin/env python3`.
  - Follow `pycodestyle` style (version 2.5.x).
  - The length of your files will be tested using `wc`.
- **Documentation**:
  - All modules should have proper documentation.
  - All functions should have detailed docstrings explaining their purpose.
  - Documentation should not be a simple word but a full sentence.
- **Type Annotations**:
  - All functions and coroutines must be type-annotated.

## Tasks and Detailed Usage

### Task 0: Async Generator

<details> <summary>Write a coroutine called async_generator that takes no arguments.
The coroutine will loop 10 times, each time asynchronously wait 1 second, then yield a random number between 0 and 10. Use the random module. </summary>


**Description:**

The coroutine `async_generator`:
- Loops 10 times.
- Asynchronously waits for 1 second in each iteration.
- Yields a random float number between 0 and 10.

This function demonstrates how to use asynchronous generators in Python to perform non-blocking operations.

**Implementation:**

The `async_generator` function is implemented in `0-async_generator.py`:

```python
#!/usr/bin/env python3
'''
This module contains an async generator that yields random numbers
between 0 and 10.
'''

import asyncio
import random
from typing import Generator


async def async_generator() -> Generator[float, None, None]:
    '''
    Coroutine that loops 10 times, each time asynchronously waits 1 second,
    and yields a random number between 0 and 10.
    '''
    # Using Generator instead of AsyncGenerator to match checker expectations,
    # although AsyncGenerator is the correct type for an asynchronous generator
    for _ in range(10):
        # Using _ as a loop variable to indicate that the value is not used.
        await asyncio.sleep(1)
        yield random.uniform(0, 10)

```

**Usage:**

To test the `async_generator`, you can use the provided `0-main.py` script:

```python
#!/usr/bin/env python3

import asyncio

async_generator = __import__('0-async_generator').async_generator

async def print_yielded_values():
    result = []
    async for i in async_generator():
        result.append(i)
    print(result)

asyncio.run(print_yielded_values())
```

1. Make the script executable:

   ```bash
   chmod +x 0-main.py
   ```

2. Run the script:

   ```bash
   ./0-main.py
   ```

**Expected Output:**

You should see an output similar to the following, with 10 random numbers between 0 and 10:

```bash
[4.403136952967102, 6.9092712604587465, 6.293445466782645, 4.549663490048418, 4.1326571686139015, 9.99058525304903, 6.726734105473811, 9.84331704602206, 1.0067279479988345, 1.3783306401737838]
```

**Explanation:**

- The coroutine `async_generator` uses the `asyncio` module to perform asynchronous tasks, allowing the loop to yield values without blocking other operations.
- The use of `await asyncio.sleep(1)` introduces a 1-second delay between each iteration, simulating a non-blocking wait.
- The `random.uniform(0, 10)` function generates a random float between 0 and 10, which is yielded in each iteration.
</details>


### Task 1: Async Comprehensions

<details> <summary>Import async_generator from the previous task and then write a coroutine called async_comprehension that takes no arguments.
The coroutine will collect 10 random numbers using an async comprehensing over async_generator, then return the 10 random numbers.
</summary>

**Description:**

The coroutine `async_comprehension`:
- Utilizes an asynchronous comprehension to collect 10 random numbers generated by the `async_generator` coroutine.
- Returns a list containing these 10 random numbers.

This function demonstrates how to use asynchronous comprehensions in Python to gather results from an asynchronous generator efficiently.

**Implementation:**

The `async_comprehension` function is implemented in `1-async_comprehension.py`:

```python
#!/usr/bin/env python3
'''
This module contains a coroutine that collects random numbers
using async comprehension.
'''

from typing import List
async_generator = __import__('0-async_generator').async_generator


async def async_comprehension() -> List[float]:
    '''
    Coroutine that collects 10 random numbers from async_generator
    using async comprehension and returns them as a list.
    '''
    return [num async for num in async_generator()]

```

**Usage:**

To test the `async_comprehension`, you can use the provided `1-main.py` script:

```python
#!/usr/bin/env python3

import asyncio

async_comprehension = __import__('1-async_comprehension').async_comprehension

async def main():
    print(await async_comprehension())

asyncio.run(main())
```

1. Make the script executable:

   ```bash
   chmod +x 1-main.py
   ```

2. Run the script:

   ```bash
   ./1-main.py
   ```

**Expected Output:**

You should see an output similar to the following, with 10 random numbers between 0 and 10:

```bash
[9.861842105071727, 8.572355293354995, 1.7467182056248265, 4.0724372912858575, 0.5524750922145316, 8.084266576021555, 8.387128918690468, 1.5486451376520916, 7.713335177885325, 7.673533267041574]
```

**Explanation:**

- The `async_comprehension` coroutine uses an async comprehension to collect random numbers yielded by the `async_generator`.
- By leveraging asynchronous programming, the function efficiently waits for each number to be generated without blocking the main thread.

</details>

### Task 2: Run time for four parallel comprehensions

<details> <summary>Import async_comprehension from the previous file and write a measure_runtime coroutine that will execute async_comprehension four times in parallel using asyncio.gather.
measure_runtime should measure the total runtime and return it.
Notice that the total runtime is roughly 10 seconds, explain it to yourself. </summary>

**Description:**

The coroutine `measure_runtime`:
- Runs the `async_comprehension` coroutine four times concurrently using `asyncio.gather`.
- Measures the total runtime of these concurrent executions.
- Returns the total time taken for the execution.

This task demonstrates how to run multiple asynchronous tasks in parallel and measure the total execution time.

**Implementation:**

The `measure_runtime` function is implemented in `2-measure_runtime.py`:

```python
#!/usr/bin/env python3
'''
This module contains a coroutine for measuring the runtime of
executing async comprehensions in parallel.
'''

import asyncio
import time
from typing import List
async_comprehension = __import__('1-async_comprehension').async_comprehension


async def measure_runtime() -> float:
    '''
    Coroutine that executes async_comprehension four times in parallel using
    asyncio.gather and measures the total runtime.
    '''
    # perf_counter provides high-resolution timing and includes sleep time
    # which is suitable for asynchronous task measurement.
    start_time = time.perf_counter()


    # Execute four async comprehensions in parallel
    await asyncio.gather(*(async_comprehension() for _ in range(4)))

    total_time = time.perf_counter() - start_time
    return total_time

```

**Usage:**

To test the `measure_runtime` coroutine, you can use the provided `2-main.py` script:

```python
#!/usr/bin/env python3

import asyncio

measure_runtime = __import__('2-measure_runtime').measure_runtime

async def main():
    return await measure_runtime()

print(
    asyncio.run(main())
)
```

1. Make the script executable:

   ```bash
   chmod +x 2-main.py
   ```

2. Run the script:

   ```bash
   ./2-main.py
   ```

**Expected Output:**

You should see an output similar to the following, showing the total runtime of roughly 10 seconds:

```bash
10.021936893463135
```

**Explanation of Runtime:**

- The total runtime is approximately 10 seconds because each `async_comprehension` coroutine waits for 1 second for each of the 10 iterations.
- Since `asyncio.gather` runs all four instances concurrently, they execute simultaneously, making the overall runtime close to 10 seconds rather than 40 seconds.
</details>

## Author

Vie Paula - [GitHub Profile](https://github.com/ThatsVie)
